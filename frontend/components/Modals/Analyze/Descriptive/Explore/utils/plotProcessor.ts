import { ChartService } from "@/services/chart/ChartService";
import { useResultStore } from "@/stores/useResultStore";
import type { ExploreAnalysisParams } from "../types";
import type { Variable } from "@/types/Variable";

// Internal helper – build stem/leaf structure from numeric values
function buildStemLeaf(values: number[]): Array<{ stem: string; leaves: number[] }> {
  const stemMap: Record<string, number[]> = {};

  values.forEach((raw) => {
    const val = Number(raw);
    if (Number.isNaN(val)) return;

    const stem = Math.floor(val / 10).toString();
    const leaf = Math.abs(val % 10);

    if (!stemMap[stem]) stemMap[stem] = [];
    stemMap[stem].push(leaf);
  });

  return Object.keys(stemMap)
    .sort((a, b) => Number(a) - Number(b))
    .map((stem) => ({
      stem,
      leaves: stemMap[stem].sort((a, b) => a - b),
    }));
}

// Helper – extract numeric values for a variable from row list
function extractValues(rows: any[], variable: Variable): number[] {
  return rows
    .map((row) => Number(row[variable.columnIndex]))
    .filter((v) => !Number.isNaN(v));
}

// Public API – called by useExploreAnalysis
export const processAndAddPlots = async (
  analyticId: number,
  groupedData: Record<
    string,
    {
      factorLevels: Record<string, string | number>;
      data: any[];
    }
  >,
  params: ExploreAnalysisParams
) => {
  const { addStatistic } = useResultStore.getState();

  const {
    dependentVariables,
    showHistogram,
    showStemAndLeaf,
  } = params;

  // Early exit – no plot option selected
  if (!showHistogram && !showStemAndLeaf) return;

  const order: Array<{ type: "Histogram" | "Stem And Leaf Plot"; enabled: boolean }> = [
    { type: "Histogram", enabled: showHistogram },
    { type: "Stem And Leaf Plot", enabled: showStemAndLeaf },
  ];

  // Collect charts first
  const chartsByType: Record<string, Array<{ title: string; output: any; component: string }>> = {};

  for (const groupKey in groupedData) {
    const group = groupedData[groupKey];
    const groupLabel = groupKey === "all_data" ? "" : ` (${groupKey})`;

    for (const depVar of dependentVariables) {
      const values = extractValues(group.data, depVar);
      if (values.length === 0) continue;

      // Histogram collect
      if (showHistogram) {
        const histTitle = `Histogram - ${depVar.name}${groupLabel}`;
        try {
          const chartJSON = ChartService.createChartJSON({
            chartType: "Histogram",
            chartData: values,
            chartMetadata: { title: histTitle, description: "Generated by Explore analysis" },
          });
          chartsByType["Histogram"] = chartsByType["Histogram"] || [];
          chartsByType["Histogram"].push({ title: histTitle, output: chartJSON, component: "Histogram" });
        } catch (err) {
          console.error("[plotProcessor] Histogram generation failed:", err);
        }
      }

      // Stem-and-leaf collect
      if (showStemAndLeaf) {
        const stemLeafData = buildStemLeaf(values);
        if (stemLeafData.length === 0) continue;
        const slTitle = `Stem-and-Leaf - ${depVar.name}${groupLabel}`;
        try {
          const chartJSON = ChartService.createChartJSON({
            chartType: "Stem And Leaf Plot",
            chartData: stemLeafData,
            chartMetadata: { title: slTitle, description: "Generated by Explore analysis" },
          });
          chartsByType["Stem And Leaf Plot"] = chartsByType["Stem And Leaf Plot"] || [];
          chartsByType["Stem And Leaf Plot"].push({ title: slTitle, output: chartJSON, component: "StemAndLeaf" });
        } catch (err) {
          console.error("[plotProcessor] Stem-and-Leaf generation failed:", err);
        }
      }
    }
  }

  // Output charts in desired order
  for (const o of order) {
    if (!o.enabled) continue;
    const list = chartsByType[o.type];
    if (!list) continue;
    for (const chart of list) {
      await addStatistic(analyticId, {
        title: chart.title,
        output_data: JSON.stringify(chart.output),
        components: chart.component,
        description: "",
      });
    }
  }
}; 