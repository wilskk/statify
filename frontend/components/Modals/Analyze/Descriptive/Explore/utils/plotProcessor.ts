import { ChartService } from "@/services/chart/ChartService";
import { useResultStore } from "@/stores/useResultStore";
import type { ExploreAnalysisParams } from "../types";
import type { Variable } from "@/types/Variable";

// Internal helper – build stem/leaf structure from numeric values
function buildStemLeaf(values: number[]): Array<{ stem: string; leaves: number[] }> {
  const stemMap: Record<string, number[]> = {};

  values.forEach((raw) => {
    const val = Number(raw);
    if (Number.isNaN(val)) return;

    const stem = Math.floor(val / 10).toString();
    const leaf = Math.abs(val % 10);

    if (!stemMap[stem]) stemMap[stem] = [];
    stemMap[stem].push(leaf);
  });

  return Object.keys(stemMap)
    .sort((a, b) => Number(a) - Number(b))
    .map((stem) => ({
      stem,
      leaves: stemMap[stem].sort((a, b) => a - b),
    }));
}

// Helper – extract numeric values for a variable from row list
function extractValues(rows: any[], variable: Variable): number[] {
  return rows
    .map((row) => Number(row[variable.columnIndex]))
    .filter((v) => !Number.isNaN(v));
}

// Public API – called by useExploreAnalysis
export const processAndAddPlots = async (
  analyticId: number,
  groupedData: Record<
    string,
    {
      factorLevels: Record<string, string | number>;
      data: any[];
    }
  >,
  params: ExploreAnalysisParams
) => {
  const { addStatistic } = useResultStore.getState();

  const {
    dependentVariables,
    showHistogram,
    showStemAndLeaf,
    boxplotType,
    factorVariables,
  } = params;

  // Early exit – no plot option selected
  if (!showHistogram && !showStemAndLeaf && boxplotType === "none") return;

  // Determine output order: Boxplot(s), Histogram(s), then Stem-and-Leaf plot(s)
  const order: Array<{ type: string; enabled: boolean }> = [
    { type: "Boxplot", enabled: boxplotType !== "none" },
    { type: "Histogram", enabled: showHistogram },
    { type: "Stem And Leaf Plot", enabled: showStemAndLeaf },
  ];

  // Collect charts first
  const chartsByType: Record<string, Array<{ title: string; output: any; component: string }>> = {};
  // Accumulator for "dependents together" boxplot
  const dependentsTogetherData: { category: string; value: number }[] = [];

  for (const groupKey in groupedData) {
    const group = groupedData[groupKey];
    const groupLabel = groupKey === "all_data" ? "" : ` (${groupKey})`;

    for (const depVar of dependentVariables) {
      const values = extractValues(group.data, depVar);
      if (values.length === 0) continue;

      // Histogram collect
      if (showHistogram) {
        // Title only contains variable (and optional group) – component already implies plot type
        const histTitle = `${depVar.name}${groupLabel}`;
        try {
          const chartJSON = ChartService.createChartJSON({
            chartType: "Histogram",
            chartData: values,
            chartMetadata: { title: histTitle, description: "Generated by Explore analysis" },
          });
          chartsByType["Histogram"] = chartsByType["Histogram"] || [];
          chartsByType["Histogram"].push({ title: histTitle, output: chartJSON, component: "Histogram" });
        } catch (err) {
          console.error("[plotProcessor] Histogram generation failed:", err);
        }
      }

      // Stem-and-leaf collect
      if (showStemAndLeaf) {
        const stemLeafData = buildStemLeaf(values);
        if (stemLeafData.length === 0) continue;
        const slTitle = `${depVar.name}${groupLabel}`;
        try {
          const chartJSON = ChartService.createChartJSON({
            chartType: "Stem And Leaf Plot",
            chartData: stemLeafData,
            chartMetadata: { title: slTitle, description: "Generated by Explore analysis" },
          });
          chartsByType["Stem And Leaf Plot"] = chartsByType["Stem And Leaf Plot"] || [];
          chartsByType["Stem And Leaf Plot"].push({ title: slTitle, output: chartJSON, component: "Stem And Leaf Plot" });
        } catch (err) {
          console.error("[plotProcessor] Stem-and-Leaf generation failed:", err);
        }
      }

      // Boxplot collect
      if (boxplotType !== "none") {
        // Helper to push chart into maps
        const pushChart = (chartType: string, title: string, data: any[], component: string) => {
          try {
            const chartJSON = ChartService.createChartJSON({
              chartType,
              chartData: data,
              chartMetadata: { title, description: "Generated by Explore analysis" },
            });
            chartsByType[chartType] = chartsByType[chartType] || [];
            chartsByType[chartType].push({ title, output: chartJSON, component });
          } catch (err) {
            console.error(`[plotProcessor] ${chartType} generation failed:`, err);
          }
        };

        if (boxplotType === "dependents-together") {
          // Accumulate current depVar values across groups
          values.forEach((v) => {
            dependentsTogetherData.push({ category: depVar.name, value: v });
          });
        }
      }
    }
  }

  // After looping through groups, handle clustered boxplots if required
  if (boxplotType === "factor-levels-together" && factorVariables.length > 0) {
    const pushChart = (chartType: string, title: string, data: any[], component: string) => {
      try {
        const chartJSON = ChartService.createChartJSON({
          chartType,
          chartData: data,
          chartMetadata: { title, description: "Generated by Explore analysis" },
        });
        chartsByType[chartType] = chartsByType[chartType] || [];
        chartsByType[chartType].push({ title, output: chartJSON, component });
      } catch (err) {
        console.error(`[plotProcessor] ${chartType} generation failed:`, err);
      }
    };

    for (const dep of dependentVariables) {
      const clusterData: { category: string; subcategory: string; value: number }[] = [];
      for (const gKey in groupedData) {
        const gRows = groupedData[gKey].data;
        for (const row of gRows) {
          const val = Number(row[dep.columnIndex]);
          if (!Number.isNaN(val)) {
            clusterData.push({ category: dep.name, subcategory: gKey, value: val });
          }
        }
      }
      if (clusterData.length > 0) {
        const chartTitle = dep.name; // Variable name only
        pushChart("Boxplot", chartTitle, clusterData, "Boxplot");
      }
    }
  }

  // After looping through all groups/dependents, handle dependents-together boxplot output
  if (boxplotType === "dependents-together" && dependentsTogetherData.length > 0) {
    const title = "Dependents Together";
    try {
      const chartJSON = ChartService.createChartJSON({
        chartType: "Boxplot",
        chartData: dependentsTogetherData,
        chartMetadata: { title, description: "Generated by Explore analysis" },
      });
      chartsByType["Boxplot"] = chartsByType["Boxplot"] || [];
      chartsByType["Boxplot"].push({ title, output: chartJSON, component: "Boxplot" }); // component name stays as Boxplot (already spaced)
    } catch (err) {
      console.error("[plotProcessor] Boxplot generation failed:", err);
    }
  }

  // Output charts in desired order
  for (const o of order) {
    if (!o.enabled) continue;
    const list = chartsByType[o.type];
    if (!list) continue;
    for (const chart of list) {
      await addStatistic(analyticId, {
        title: chart.title,
        output_data: JSON.stringify(chart.output),
        components: chart.component,
        description: "",
      });
    }
  }
};