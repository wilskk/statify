import { ChartOptions, FrequencyTable } from "../types";
import { useResultStore } from "@/stores/useResultStore";
import { ChartService } from "@/services/chart/ChartService";

// Map Frequencies modal chart type → (ChartService chart type, component name)
const chartTypeMeta: Record<NonNullable<ChartOptions["type"]>, { chartServiceType: string; component: string }> = {
  barCharts: { chartServiceType: "Vertical Bar Chart", component: "Bar" },
  pieCharts: { chartServiceType: "Pie Chart", component: "Pie" },
  histograms: { chartServiceType: "Histogram", component: "Histogram" },
};

/**
 * Processes frequency tables and chart options to generate and add charts to the results.
 * @param analyticId - The ID of the parent analysis.
 * @param frequencyTables - The frequency table data from the worker.
 * @param chartOptions - The chart options selected by the user.
 */
export const processAndAddCharts = async (
    analyticId: number,
    frequencyTables: { [variableName: string]: FrequencyTable },
    chartOptions: ChartOptions
) => {
    const { addStatistic } = useResultStore.getState();

    // Collect charts by type for ordered output
    const order: NonNullable<ChartOptions["type"]>[] = ["barCharts", "pieCharts", "histograms"];
    const chartsByType: Record<string, Array<{ title: string; output: any; component: string }>> = {};

    for (const varName in frequencyTables) {
        const table = frequencyTables[varName];
        if (!table || !table.rows || table.rows.length === 0) continue;

        const chartData = {
            labels: table.rows.map(row => row.label),
            datasets: [
                {
                    label: chartOptions.values === 'percentages' ? 'Percentage' : 'Frequency',
                    data: table.rows.map(row => chartOptions.values === 'percentages' ? row.validPercent : row.frequency),
                }
            ]
        };

        // Re-use the table title (or variable name) for the chart title so it matches
        // frequency table output (avoids redundancy like "Bar Chart for …").
        const chartTitle = table.title || varName;
        const chartComponent = chartOptions.type ? chartTypeMeta[chartOptions.type].component : "Bar";

        let outputData: any;
        try {
            if (chartOptions.type && chartOptions.type !== "histograms") {
                // Bar & Pie charts – gunakan ChartService
                const chartType = chartTypeMeta[chartOptions.type].chartServiceType;
                const processedChartData = table.rows.map(row => ({
                    category: row.label,
                    value: chartOptions.values === 'percentages' ? (row.validPercent ?? row.percent ?? 0) : row.frequency,
                }));

                outputData = ChartService.createChartJSON({
                    chartType,
                    chartData: processedChartData,
                    chartMetadata: {
                        title: chartTitle,
                        description: `Generated by Frequencies analysis (${chartOptions.values})`,
                    },
                    chartConfig: { useAxis: true },
                });
            } else if (chartOptions.type === "histograms") {
                // Histogram – bangun kembali array nilai mentah berdasarkan frekuensi
                const values: number[] = [];
                table.rows.forEach(row => {
                    const val = Number(row.label);
                    if (!Number.isNaN(val)) {
                        const freq = row.frequency || 0;
                        for (let i = 0; i < freq; i++) {
                            values.push(val);
                        }
                    }
                });

                outputData = ChartService.createChartJSON({
                    chartType: "Histogram",
                    chartData: values,
                    chartMetadata: {
                        title: chartTitle,
                        description: `Generated by Frequencies analysis (${chartOptions.values})`,
                    },
                    chartConfig: { useAxis: true },
                });
            } else {
                // Fallback – seharusnya tidak terjadi
                outputData = { data: chartData, options: {} };
            }
        } catch (err) {
            console.error('[chartProcessor] Failed to build ChartJSON:', err);
            outputData = { data: chartData, options: {} };
        }

        const key = chartOptions.type || "barCharts";
        chartsByType[key] = chartsByType[key] || [];
        chartsByType[key].push({ title: chartTitle, output: outputData, component: chartComponent });
    }

    // Output in desired order
    for (const typeKey of order) {
        const chartList = chartsByType[typeKey];
        if (!chartList || chartList.length === 0) continue;

        for (const chart of chartList) {
            await addStatistic(analyticId, {
                title: chart.title,
                output_data: JSON.stringify(chart.output),
                components: chart.component,
                description: '',
            });
        }
    }
}; 