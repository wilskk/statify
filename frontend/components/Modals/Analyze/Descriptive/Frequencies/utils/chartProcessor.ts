import { ChartOptions, FrequencyTable } from '../types';
import { useResultStore } from '@/stores/useResultStore';
import { ChartService } from "@/services/chart/ChartService";

// Helper function to get the appropriate chart title
const getChartTitle = (type: string | null, varName: string): string => {
    switch(type) {
        case 'barCharts': return `Bar Chart for ${varName}`;
        case 'pieCharts': return `Pie Chart for ${varName}`;
        case 'histograms': return `Histogram for ${varName}`;
        default: return `Chart for ${varName}`;
    }
};

// Helper function to get the chart component type name
const getChartComponentType = (type: string | null): string => {
    switch(type) {
        case 'barCharts': return 'Bar';
        case 'pieCharts': return 'Pie';
        case 'histograms': return 'Histogram';
        default: return 'Bar';
    }
};

// Helper function to map Frequencies chart option type to ChartService chart type
const chartTypeMap: Record<NonNullable<ChartOptions["type"]>, string> = {
    barCharts: "Vertical Bar Chart",
    pieCharts: "Pie Chart",
    histograms: "Histogram", // Currently unused â€“ falls back to legacy handling below
};

/**
 * Processes frequency tables and chart options to generate and add charts to the results.
 * @param analyticId - The ID of the parent analysis.
 * @param frequencyTables - The frequency table data from the worker.
 * @param chartOptions - The chart options selected by the user.
 */
export const processAndAddCharts = async (
    analyticId: number,
    frequencyTables: { [variableName: string]: FrequencyTable },
    chartOptions: ChartOptions
) => {
    const { addStatistic } = useResultStore.getState();

    // Collect charts by type for ordered output
    const order: NonNullable<ChartOptions["type"]>[] = ["barCharts", "pieCharts", "histograms"];
    const chartsByType: Record<string, Array<{ title: string; output: any; component: string }>> = {};

    for (const varName in frequencyTables) {
        const table = frequencyTables[varName];
        if (!table || !table.rows || table.rows.length === 0) continue;

        const chartData = {
            labels: table.rows.map(row => row.label),
            datasets: [
                {
                    label: chartOptions.values === 'percentages' ? 'Percentage' : 'Frequency',
                    data: table.rows.map(row => chartOptions.values === 'percentages' ? row.validPercent : row.frequency),
                }
            ]
        };

        const chartTitle = getChartTitle(chartOptions.type, table.title || varName);
        const chartComponent = getChartComponentType(chartOptions.type);

        let outputData: any;
        try {
            if (chartOptions.type && chartOptions.type !== "histograms") {
                const chartType = chartTypeMap[chartOptions.type];
                const processedChartData = table.rows.map(row => ({
                    category: row.label,
                    value: chartOptions.values === 'percentages' ? (row.validPercent ?? row.percent ?? 0) : row.frequency,
                }));

                outputData = ChartService.createChartJSON({
                    chartType,
                    chartData: processedChartData,
                    chartMetadata: {
                        title: chartTitle,
                        description: `Generated by Frequencies analysis (${chartOptions.values})`,
                    },
                    chartConfig: { useAxis: true },
                });
            } else {
                outputData = {
                    data: chartData,
                    options: { ...(chartOptions.type === 'histograms' && { showNormalCurve: chartOptions.showNormalCurveOnHistogram }) },
                };
            }
        } catch (err) {
            console.error('[chartProcessor] Failed to build ChartJSON:', err);
            outputData = { data: chartData, options: {} };
        }

        const key = chartOptions.type || 'barCharts';
        chartsByType[key] = chartsByType[key] || [];
        chartsByType[key].push({ title: chartTitle, output: outputData, component: chartComponent });
    }

    // Output in desired order
    for (const typeKey of order) {
        const chartList = chartsByType[typeKey];
        if (!chartList || chartList.length === 0) continue;

        for (const chart of chartList) {
            await addStatistic(analyticId, {
                title: chart.title,
                output_data: JSON.stringify(chart.output),
                components: chart.component,
                description: '',
            });
        }
    }
}; 