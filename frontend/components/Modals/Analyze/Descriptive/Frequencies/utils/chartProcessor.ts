import { ChartOptions, FrequencyTable } from "../types";
import { useResultStore } from "@/stores/useResultStore";
import { ChartService } from "@/services/chart/ChartService";
import { DataProcessingService } from "@/services/chart/DataProcessingService";

// Date utility functions
function isDateString(value: string): boolean {
    if (typeof value !== 'string') return false;
    const datePattern = /^\d{2}-\d{2}-\d{4}$/;
    if (!datePattern.test(value)) return false;
    
    const [day, month, year] = value.split('-').map(Number);
    if (day < 1 || day > 31 || month < 1 || month > 12 || year < 1900 || year > 2100) return false;
    
    const date = new Date(year, month - 1, day);
    return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
}

function dateStringToSpssSeconds(dateStr: string): number | null {
    if (!isDateString(dateStr)) return null;
    
    const [day, month, year] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day);
    const spssEpoch = new Date(1582, 9, 14); // October 14, 1582
    const diffMs = date.getTime() - spssEpoch.getTime();
    return Math.floor(diffMs / 1000);
}

// Map Frequencies modal chart type → (ChartService chart type, component name)
const chartTypeMeta: Record<NonNullable<ChartOptions["type"]>, { chartServiceType: string; component: string }> = {
  barCharts: { chartServiceType: "Vertical Bar Chart", component: "Bar" },
  pieCharts: { chartServiceType: "Pie Chart", component: "Pie" },
  histograms: { chartServiceType: "Histogram", component: "Histogram" },
};

/**
 * Processes frequency tables and chart options to generate and add charts to the results.
 * @param analyticId - The ID of the parent analysis.
 * @param frequencyTables - The frequency table data from the worker.
 * @param chartOptions - The chart options selected by the user.
 */
export const processAndAddCharts = async (
    analyticId: number,
    frequencyTables: { [variableName: string]: FrequencyTable },
    chartOptions: ChartOptions
) => {
    const { addStatistic } = useResultStore.getState();

    // Collect charts by type for ordered output
    const order: NonNullable<ChartOptions["type"]>[] = ["barCharts", "pieCharts", "histograms"];
    const chartsByType: Record<string, Array<{ title: string; output: any; component: string }>> = {};

    for (const varName in frequencyTables) {
        const table = frequencyTables[varName];
        if (!table || !table.rows || table.rows.length === 0) continue;

        const chartData = {
            labels: table.rows.map(row => row.label),
            datasets: [
                {
                    label: chartOptions.values === 'percentages' ? 'Percentage' : 'Frequency',
                    data: table.rows.map(row => chartOptions.values === 'percentages' 
                        ? (row.validPercent ?? row.percent ?? 0)
                        : (row.frequency ?? 0)
                    ),
                }
            ]
        };

        /*
         * Build a descriptive title for the chart. Tests (and users) expect the
         * title to contain the chart type (e.g. "Bar Chart", "Pie Chart"). We
         * therefore prefix the original frequency-table title with the chart type
         * label. For example:
         *   "Var1 Frequencies"  ->  "Bar Chart: Var1 Frequencies"
         */
        const chartTypeLabelMap: Record<NonNullable<ChartOptions["type"]>, string> = {
            barCharts: "Bar Chart",
            pieCharts: "Pie Chart",
            histograms: "Histogram",
        } as const;

        let chartTitle = table.title || varName;
        if (chartOptions.type) {
            const label = chartTypeLabelMap[chartOptions.type];
            // Ensure we only prepend if not already included.
            if (label && !chartTitle.includes(label)) {
                chartTitle = `${label}: ${chartTitle}`;
            }
        }
        const chartComponent = chartOptions.type ? chartTypeMeta[chartOptions.type].component : "Bar";

        let outputData: any;
        try {
            if (chartOptions.type && chartOptions.type !== "histograms") {
                // Bar & Pie charts – gunakan ChartService
                const chartType = chartTypeMeta[chartOptions.type].chartServiceType;
                const processedChartData = table.rows.map(row => ({
                    category: row.label,
                    value: chartOptions.values === 'percentages' ? (row.validPercent ?? row.percent ?? 0) : row.frequency,
                }));

                outputData = ChartService.createChartJSON({
                    chartType,
                    chartData: processedChartData,
                    chartMetadata: {
                        title: chartTitle,
                        description: `Generated by Frequencies analysis (${chartOptions.values})`,
                    },
                    chartConfig: { useAxis: true },
                });
            } else if (chartOptions.type === "histograms") {
                // Histogram – bangun kembali array nilai mentah berdasarkan frekuensi
                const values: number[] = [];
                
                table.rows.forEach(row => {
                    let val: number;
                    
                    // Check if the label is a date string and convert to SPSS seconds
                    if (typeof row.label === 'string' && isDateString(row.label)) {
                        const spssSeconds = dateStringToSpssSeconds(row.label);
                        if (spssSeconds !== null) {
                            val = spssSeconds;
                        } else {
                            return; // Skip invalid date
                        }
                    } else {
                        val = Number(row.label);
                        if (Number.isNaN(val)) {
                            return; // Skip non-numeric values
                        }
                    }
                    
                    const freq = row.frequency || 0;
                    for (let i = 0; i < freq; i++) {
                        values.push(val);
                    }
                });

                if (values.length === 0) {
                    console.warn('[chartProcessor] No valid data for histogram');
                    outputData = { data: [], options: {} };
                } else {
                    try {
                        // Convert values array to rawData format for DataProcessingService
                        const rawDataForHist = values.map(val => [val]);
                        const variablesForHist = [{ name: 'value' }];
                        
                        // Process data using DataProcessingService first
                        const processedData = DataProcessingService.processDataForChart({
                            chartType: 'Histogram',
                            rawData: rawDataForHist,
                            variables: variablesForHist,
                            chartVariables: { y: ['value'] }
                        });

                        // Then create chart JSON
                        outputData = ChartService.createChartJSON({
                            chartType: "Histogram",
                            chartData: processedData.data,
                            chartVariables: { y: ['value'] },
                            chartMetadata: {
                                title: chartTitle,
                                description: `Generated by Frequencies analysis (${chartOptions.values})`,
                                axisInfo: processedData.axisInfo
                            },
                            chartConfig: { 
                                useAxis: true,
                                axisLabels: { x: 'Value', y: 'Frequency' }
                            },
                        });
                    } catch (histogramError) {
                        console.error('[chartProcessor] Error creating histogram:', histogramError);
                        outputData = { data: [], options: {} };
                    }
                }
            } else {
                // Fallback – seharusnya tidak terjadi
                outputData = { data: chartData, options: {} };
            }
        } catch (err) {
            console.error('[chartProcessor] Failed to build ChartJSON:', err);
            outputData = { data: chartData, options: {} };
        }

        const key = chartOptions.type || "barCharts";
        chartsByType[key] = chartsByType[key] || [];
        chartsByType[key].push({ title: chartTitle, output: outputData, component: chartComponent });
    }

    // Output in desired order
    for (const typeKey of order) {
        const chartList = chartsByType[typeKey];
        if (!chartList || chartList.length === 0) continue;

        for (const chart of chartList) {
            await addStatistic(analyticId, {
                title: chart.title,
                output_data: JSON.stringify(chart.output),
                components: chart.component,
                description: '',
            });
        }
    }
};